# This program is free software; you can redistribute it and/or modify it under
# the terms of the GNU General Public License version 2 as published by the
# Free Software Foundation.
#
# Copyright (C) 2012-5 Michael D. Taht, Toke Høiland-Jørgensen, Sebastian
# Moeller Additional hackery & standing on shoulders of giants (C) 2019 Kevin
# Darbyshire-Bryant
#
. /lib/functions/network.sh
. ${SQM_LIB_DIR}/defaults.sh
QDISC=cake

# Basic Configuration Options
#
# do we want LE/BK differentiation, ie. have the patched diffserv5 mode?
[ "$1" -eq 5 ] && LESUPPORT=1 || LESUPPORT=0
# Duration in seconds for flow to be de-prioritised
DURUP=30
DURDN=30

# where to store our status in connmark (0-23)
# in this case, top 9bits
SHIFTVAL=22

DSCPS=$(( 8 << ${SHIFTVAL} ))
DSCPF=$(( 4 << ${SHIFTVAL} ))
DSCPN=$(( 2 << ${SHIFTVAL} ))
DSCPD=$(( 1 << ${SHIFTVAL} ))
DSCPSF=$(( ${DSCPS} | ${DSCPF} ))
DSCPFN=$(( ${DSCPN} | ${DSCPF} ))
DSCPFND=$(( ${DSCPF} | ${DSCPN} | ${DSCPD} ))

DSCP=$(( 0x3f0 << ${SHIFTVAL} ))
CS1D=$(( ((8 << 4) << ${SHIFTVAL} ) | ${DSCPD} ))

# simplified Rate * 1000 * duration / 9 ie 1000/9 = 111
CONNBDN=$(( ${DOWNLINK} * 111 * ${DURDN} ))
CONNBUP=$(( ${UPLINK}   * 111 * ${DURUP} ))

if [ "$LESUPPORT" -eq 1 ] ; then
	INGRESS_CAKE_OPTS="diffserv5"
	EGRESS_CAKE_OPTS="diffserv5"
else
	INGRESS_CAKE_OPTS="diffserv4"
	EGRESS_CAKE_OPTS="diffserv4"
fi

#seed an ipset
nslookup pub.3gppnetwork.org >/dev/null 2>&1

network_get_subnet SUBNET lan
network_find_wan6 ifc_wan6 && network_get_prefix6 PREFIX "${ifc_wan6}"

egress() {
    SILENT=1 $TC qdisc del dev $IFACE root
    $TC qdisc add dev $IFACE root cake bandwidth ${UPLINK}kbit \
	    $( get_cake_lla_string ) ${EGRESS_CAKE_OPTS} ${EQDISC_OPTS}

    # Put act_ctinfo on the egress interface to set DSCP from the stored connmark.
    # This seems counter intuitive but it ensures once the mark is set that all
    # subsequent egress packets have the same stored DSCP. This avoids the need
    # for iptables run/mark every packet.

    $TC filter add dev $IFACE protocol all u32 \
	match u32 0 0 \
	action ctinfo dscp ${DSCP} ${DSCPS}
}


ingress() {

    SILENT=1 $TC qdisc del dev $IFACE handle ffff: ingress
    $TC qdisc add dev $IFACE handle ffff: ingress

    SILENT=1 $TC qdisc del dev $DEV root

    [ "$ZERO_DSCP_INGRESS" -eq "1" ] && INGRESS_CAKE_OPTS="$INGRESS_CAKE_OPTS wash"

    $TC qdisc add dev $DEV root cake bandwidth ${DOWNLINK}kbit \
	    $( get_cake_lla_string ) ${INGRESS_CAKE_OPTS} ${IQDISC_OPTS}

    $IP link set dev $DEV up

    # restore DSCP from conntrack mark into packet
    # redirect all packets arriving in $IFACE to ifb0
    $TC filter add dev $IFACE parent ffff: protocol all u32 \
	match u32 0 0 \
	action ctinfo dscp ${DSCP} ${DSCPS} \
	action mirred egress redirect dev $DEV
}

ipt_setup() {
    # Configure iptables chains to mark packets
    ipt -t mangle -N QOS_SQM_${IFACE}
    ipt -t mangle -N QOS_SQM_US_${IFACE}
    ipt -t mangle -N QOS_SQM_US_REMAP_${IFACE}
    ipt -t mangle -N QOS_SQM_UFO_${IFACE}
    ipt -t mangle -N QOS_SQM_UFR_${IFACE}
    ipt -t mangle -N QOS_SQM_UFo_${IFACE}
    ipt -t mangle -N QOS_SQM_UFr_${IFACE}
    ipt -t mangle -N QOS_NFA_UN_${IFACE}

# 'non-dynamic, fixed' rules
#
# Change DSCP of relevant ipsets/hosts/ports and store the DSCP to connmark using savedscp

#ipv4
#
# Bluray
ipset -q add VI_4  bluray timeout 0
# AV-Amp
ipset -q add VI_4  [av-amp] timeout 0

# >>> QOS_SQM_US_REMAP_${IFACE} - DSCP remapping chain
if [ "${LESUPPORT}" = 1 ]; then
	# Customise
	# if it's DSCP LE & tcp and from my NAS then re-map to BK, as it's backup traffic
	ipt -t mangle -A QOS_SQM_US_REMAP_${IFACE} -m dscp --dscp 0x01 -p tcp -s waldorf -m tcp -m multiport ! --sports 6981 -j DSCP --set-dscp-class CS1
	ipt -t mangle -A QOS_SQM_US_REMAP_${IFACE} -m dscp --dscp 0x08 -p tcp -s waldorf -m tcp -m multiport --sports 6981 -j DSCP --set-dscp 1
	# if it's DSCP CS1 & udp and from my NAS then it turns out it's bittorrent make that LE
	ipt -t mangle -A QOS_SQM_US_REMAP_${IFACE} -m dscp --dscp 0x08 -p udp -s waldorf -j DSCP --set-dscp 1
	# End Customise
else
	# Customise
	#I have nothing to do here, but YOU may want to add rules to change non BK/LE traffic
	false
	# End Customise
fi
# save it
ipt -t mangle -A QOS_SQM_US_REMAP_${IFACE} -j CONNMARK --set-dscpmark ${DSCP}/${DSCPSF}
# <<< the end

# >>> QOS_SQM_US_${IFACE} The FIXED rules
# if dscp not = 0 then special case packets that already have an application set DSCP
# goto QOS_SQM_US_REMAP_${IFACE}
ipt  -t mangle -A QOS_SQM_US_${IFACE} -m dscp ! --dscp 0x00 -g QOS_SQM_US_REMAP_${IFACE}

# else fall through

# Customise

# ipv4 rules
#
# Bittorrent box - is a PAIN & keeps changing. Currently it sends BT UDP traffic as Bulk so that gets dealt with
# by the remap chain above BUT the BT TCP traffic isn't marked, not only that it doesn't come from a fixed port
# anymore.  So I have to assume it is BT traffic unless it matches some known ports
$IPTABLES -t mangle -A QOS_SQM_US_${IFACE} -p tcp -s waldorf -m tcp -m multiport ! --sports 12557 -m multiport ! --dports 443,22 -m comment --comment "BT DSCP LE" -j DSCP --set-dscp 1

# traffic in ipv4 ipset matches
# If you want a connection to remain as CS0 Best Effort, you force the DSCP Fixed bit
if [ "${LESUPPORT}" = 1 ]; then
	$IPTABLES -t mangle -A QOS_SQM_US_${IFACE} -m set --match-set LE_4 dst -j DSCP --set-dscp 1 -m comment --comment "LE ipset"
	$IPTABLES -t mangle -A QOS_SQM_US_${IFACE} -m set --match-set LE_4 src -j DSCP --set-dscp 1 -m comment --comment "LE ipset"
fi
$IPTABLES -t mangle -A QOS_SQM_US_${IFACE} -m set --match-set BK_4 dst -j DSCP --set-dscp-class CS1 -m comment --comment "Bulk CS1 ipset"
$IPTABLES -t mangle -A QOS_SQM_US_${IFACE} -m set --match-set BK_4 src -j DSCP --set-dscp-class CS1 -m comment --comment "Bulk CS1 ipset"
$IPTABLES -t mangle -A QOS_SQM_US_${IFACE} -m set --match-set BE_4 dst -j CONNMARK --set-xmark ${DSCPF}/${DSCPF} -m comment --comment "Best Effort CS0 ipset"
$IPTABLES -t mangle -A QOS_SQM_US_${IFACE} -m set --match-set BE_4 src -j CONNMARK --set-xmark ${DSCPF}/${DSCPF} -m comment --comment "Best Effort CS0 ipset"
$IPTABLES -t mangle -A QOS_SQM_US_${IFACE} -m set --match-set VI_4 dst -j DSCP --set-dscp-class CS3 -m comment --comment "Vid CS3 ipset"
$IPTABLES -t mangle -A QOS_SQM_US_${IFACE} -m set --match-set VI_4 src -j DSCP --set-dscp-class CS3 -m comment --comment "Vid CS3 ipset"
$IPTABLES -t mangle -A QOS_SQM_US_${IFACE} -m set --match-set VO_4 dst -j DSCP --set-dscp-class CS4 -m comment --comment "Voice CS4 ipset"
$IPTABLES -t mangle -A QOS_SQM_US_${IFACE} -m set --match-set VO_4 src -j DSCP --set-dscp-class CS4 -m comment --comment "Voice CS4 ipset"

# ipv6
$IP6TABLES -t mangle -A QOS_SQM_US_${IFACE} -p tcp -s waldorf -m tcp -m multiport ! --sports 12557 -m multiport ! --dports 443,22 -m comment --comment "BT DSCP LE" -j DSCP --set-dscp 1

# traffic in ipv6 ipset matches
# If you want a connection to remain as CS0 Best Effort, you force the DSCP Fixed bit
if [ "${LESUPPORT}" = 1 ]; then
	$IP6TABLES -t mangle -A QOS_SQM_US_${IFACE} -m set --match-set LE_6 dst -j DSCP --set-dscp 1 -m comment --comment "LE ipset"
	$IP6TABLES -t mangle -A QOS_SQM_US_${IFACE} -m set --match-set LE_6 src -j DSCP --set-dscp 1 -m comment --comment "LE ipset"
fi
$IP6TABLES -t mangle -A QOS_SQM_US_${IFACE} -m set --match-set BK_6 dst -j DSCP --set-dscp-class CS1 -m comment --comment "Bulk CS1 ipset"
$IP6TABLES -t mangle -A QOS_SQM_US_${IFACE} -m set --match-set BK_6 src -j DSCP --set-dscp-class CS1 -m comment --comment "Bulk CS1 ipset"
$IP6TABLES -t mangle -A QOS_SQM_US_${IFACE} -m set --match-set BE_6 dst -j CONNMARK --set-xmark ${DSCPF}/${DSCPF} -m comment --comment "Best Effort CS0 ipset"
$IP6TABLES -t mangle -A QOS_SQM_US_${IFACE} -m set --match-set BE_6 src -j CONNMARK --set-xmark ${DSCPF}/${DSCPF} -m comment --comment "Best Effort CS0 ipset"
$IP6TABLES -t mangle -A QOS_SQM_US_${IFACE} -m set --match-set VI_6 dst -j DSCP --set-dscp-class CS3 -m comment --comment "Vid CS3 ipset"
$IP6TABLES -t mangle -A QOS_SQM_US_${IFACE} -m set --match-set VI_6 src -j DSCP --set-dscp-class CS3 -m comment --comment "Vid CS3 ipset"
$IP6TABLES -t mangle -A QOS_SQM_US_${IFACE} -m set --match-set VO_6 dst -j DSCP --set-dscp-class CS4 -m comment --comment "Voice CS4 ipset"
$IP6TABLES -t mangle -A QOS_SQM_US_${IFACE} -m set --match-set VO_6 src -j DSCP --set-dscp-class CS4 -m comment --comment "Voice CS4 ipset"

# back to some host/application specific
#unificontroller
$IPTABLES -t mangle -A QOS_SQM_US_${IFACE} -p tcp -s unificontroller -m tcp -m multiport --dports 8883 -m comment --comment "UnifiController CS0 BE" -j CONNMARK --set-xmark ${DSCPF}/${DSCPF}

#Apple push notification/mail
$IPTABLES -t mangle -A QOS_SQM_US_${IFACE} -p tcp -d 17.0.0.0/8 -m tcp -m multiport --dports 5223,993 -m comment --comment "APNS,mail CS0 BE" -j CONNMARK --set-xmark ${DSCPF}/${DSCPF}

#Facetime is interesting. Apple say that for firewall purposes only certain ports are used, they don't say if that's source
#or destination. Turns out it's both, so look for connections with both a source & destination port in the Facetime range
ipt -t mangle -A QOS_SQM_US_${IFACE} -p udp -m udp -m multiport --sports 3478:3497,16384:16387,16393:16402 -m multiport --dports 3478:3497,16384:16387,16393:16402,16609:16618 -m comment --comment "Facetime CS3 Vid" -j DSCP --set-dscp-class CS3

#Zoom - connections go to Zoom servers with dest ports 8801-8810
$IPTABLES -t mangle -A QOS_SQM_US_${IFACE} -p udp -m udp -m set --match-set Zoom_4 dst -m multiport --dports 8801:8810 -j DSCP --set-dscp-class CS3 -m comment --comment "Zoom CS3 VI"
$IP6TABLES -t mangle -A QOS_SQM_US_${IFACE} -p udp -m udp -m set --match-set Zoom_6 dst -m multiport --dports 8801:8810 -j DSCP --set-dscp-class CS3 -m comment --comment "Zoom CS3 VI"

#Whatsapp Video
ipt -t mangle -A QOS_SQM_US_${IFACE} -p udp -m udp -m multiport --dports 3478 -m comment --comment "Whatsapp CS3 VI" -j DSCP --set-dscp-class CS3

#Irc
ipt -t mangle -A QOS_SQM_US_${IFACE} -p tcp -m tcp -m multiport --dports 6697 -m comment --comment "IRC CS0 BE" -j CONNMARK --set-xmark 0x01000000/0x01000000

#Icmp/v6
#$IPTABLES -t mangle -A QOS_SQM_US_${IFACE} -p icmp -m comment --comment "Ping CS0 BE" -j CONNMARK --set-xmark ${DSCPF}/${DSCPF}
#$IP6TABLES -t mangle -A QOS_SQM_US_${IFACE} -p icmpv6 -m comment --comment "Ping CS0 BE" -j CONNMARK --set-xmark ${DSCPF}/${DSCPF}
$IPTABLES -t mangle -A QOS_SQM_US_${IFACE} -p icmp -m icmp --icmp-type 0 -m comment --comment "Ping CS6 VO" -j DSCP --set-dscp-class CS6
$IP6TABLES -t mangle -A QOS_SQM_US_${IFACE} -p icmpv6 -m icmp6 --icmpv6-type 129 -m comment --comment "Ping CS6 VO" -j DSCP --set-dscp-class CS6

#Wireguard
ipt -t mangle -A QOS_SQM_US_${IFACE} -p udp -m udp -m multiport --sports 51820 -m comment --comment "WG CS0 BE" -j CONNMARK --set-xmark ${DSCPF}/${DSCPF}


# End Customise
# Store the decided DSCP into connmark (for later restoration by ctinfo)
ipt -t mangle -A QOS_SQM_US_${IFACE} -j CONNMARK --set-dscpmark ${DSCP}/${DSCPS}
# if we stored a non best effort DSCP then set DSCPF bit to lock it in place, there's no traffic based deprioritisation required
ipt -t mangle -A QOS_SQM_US_${IFACE} -m connmark ! --mark 0/${DSCP} -j CONNMARK --set-xmark ${DSCPF}/${DSCPF}
# <<< ---- End of 'hard/fixed' rules


# >>> Dynamic rules - These get run when a connection first goes above our bulk transfer size limit.
# Set the stored DSCP to CS1 (bulk) - this is the dynamic de-prioritisation.
# CS1 = 8 << 2 = 0x20, setting our Fixed bit = 0x21
ipt -t mangle -A QOS_SQM_UFO_${IFACE} -j CONNMARK --set-xmark ${CS1D}/${CS1D}
$IPTABLES -t mangle -A QOS_SQM_UFO_${IFACE} -j SET --add-set BK_4 dst --exist
$IP6TABLES -t mangle -A QOS_SQM_UFO_${IFACE} -j SET --add-set BK_6 dst --exist

ipt -t mangle -A QOS_SQM_UFR_${IFACE} -j CONNMARK --set-xmark ${CS1D}/${CS1D}
$IPTABLES -t mangle -A QOS_SQM_UFR_${IFACE} -j SET --add-set BK_4 src --exist
$IP6TABLES -t mangle -A QOS_SQM_UFR_${IFACE} -j SET --add-set BK_6 src --exist
# <<< --- End of Dynamic Rules

# netify integration
#ipv4
if [ "${LESUPPORT}" = 1 ]; then
	$IPTABLES -t mangle -A QOS_NFA_UN_eth0 -m set --match-set NFA4_PRIO_LE dst,dst,src -j DSCP --set-dscp 1
fi
$IPTABLES -t mangle -A QOS_NFA_UN_eth0 -m set --match-set NFA4_PRIO_BK dst,dst,src -j DSCP --set-dscp-class CS1
$IPTABLES -t mangle -A QOS_NFA_UN_eth0 -m set --match-set NFA4_PRIO_BE dst,dst,src -j CONNMARK --set-xmark ${DSCPN}/${DSCPN}
$IPTABLES -t mangle -A QOS_NFA_UN_eth0 -m set --match-set NFA4_PRIO_VI dst,dst,src -j DSCP --set-dscp-class CS3
$IPTABLES -t mangle -A QOS_NFA_UN_eth0 -m set --match-set NFA4_PRIO_VO dst,dst,src -j DSCP --set-dscp-class CS4

$IPTABLES -t mangle -A QOS_NFA_UN_eth0 -j CONNMARK --set-dscpmark ${DSCP}/${DSCPS}
$IPTABLES -t mangle -A QOS_NFA_UN_eth0 -m connmark ! --mark 0/${DSCP} -j CONNMARK --set-xmark ${DSCPN}/${DSCPN}

#ipv6
if [ "${LESUPPORT}" = 1 ]; then
	$IP6TABLES -t mangle -A QOS_NFA_UN_eth0 -m set --match-set NFA6_PRIO_LE dst,dst,src -j DSCP --set-dscp 1
fi
$IP6TABLES -t mangle -A QOS_NFA_UN_eth0 -m set --match-set NFA6_PRIO_BK dst,dst,src -j DSCP --set-dscp-class CS1
$IP6TABLES -t mangle -A QOS_NFA_UN_eth0 -m set --match-set NFA6_PRIO_BE dst,dst,src -j CONNMARK --set-xmark ${DSCPN}/${DSCPN}
$IP6TABLES -t mangle -A QOS_NFA_UN_eth0 -m set --match-set NFA6_PRIO_VI dst,dst,src -j DSCP --set-dscp-class CS3
$IP6TABLES -t mangle -A QOS_NFA_UN_eth0 -m set --match-set NFA6_PRIO_VO dst,dst,src -j DSCP --set-dscp-class CS4

$IP6TABLES -t mangle -A QOS_NFA_UN_eth0 -j CONNMARK --set-dscpmark ${DSCP}/${DSCPS}
$IP6TABLES -t mangle -A QOS_NFA_UN_eth0 -m connmark ! --mark 0/${DSCP} -j CONNMARK --set-xmark ${DSCPN}/${DSCPN}
# <<< -- End of netify integration

# >>> It all starts here.  This is the entry point that combines all the above rules
# CAKE chain to combine hard/dynamic rules
# Send unmarked connections to the hard/fixed marking chain
ipt -t mangle -A QOS_SQM_${IFACE} -m connmark --mark 0/${DSCPS} -g QOS_SQM_US_${IFACE}

ipt -t mangle -A QOS_SQM_${IFACE} -m connbytes ! --connbytes 20 --connbytes-dir both \
	--connbytes-mode packets -g QOS_NFA_UN_${IFACE}

# Send marked connections over CONNB bytes and not DSCPFixed to the dynamic rules
# original direction first - the original src ip is local
# ipv4
if [ "$SUBNET" ] ; then
	$IPTABLES -t mangle -A QOS_SQM_${IFACE} -m conntrack --ctorigsrc ${SUBNET} -g QOS_SQM_UFo_${IFACE}
	$IPTABLES -t mangle -A QOS_SQM_${IFACE} -m conntrack --ctreplsrc ${SUBNET} -g QOS_SQM_UFr_${IFACE}

	# orig direction
	$IPTABLES -t mangle -A QOS_SQM_UFo_${IFACE} \
	-m connbytes --connbytes ${CONNBUP} --connbytes-dir original --connbytes-mode bytes \
	-g QOS_SQM_UFO_${IFACE}
	$IPTABLES -t mangle -A QOS_SQM_UFo_${IFACE} \
	-m connbytes --connbytes ${CONNBDN} --connbytes-dir reply  --connbytes-mode bytes \
	-g QOS_SQM_UFO_${IFACE}

	# reply direction - reply src IP is local
	$IPTABLES -t mangle -A QOS_SQM_UFr_${IFACE} \
	-m connbytes --connbytes ${CONNBDN} --connbytes-dir original --connbytes-mode bytes \
	-g QOS_SQM_UFR_${IFACE}
	$IPTABLES -t mangle -A QOS_SQM_UFr_${IFACE} \
	-m connbytes --connbytes ${CONNBUP} --connbytes-dir reply --connbytes-mode bytes \
	-g QOS_SQM_UFR_${IFACE}
fi

# and now for ipv6.
if [ "$PREFIX" ] ; then
	$IP6TABLES -t mangle -A QOS_SQM_${IFACE} -m conntrack --ctorigsrc ${PREFIX} -g QOS_SQM_UFo_${IFACE}
	$IP6TABLES -t mangle -A QOS_SQM_${IFACE} -m conntrack --ctreplsrc ${PREFIX} -g QOS_SQM_UFr_${IFACE}

	# orig direction
	$IP6TABLES -t mangle -A QOS_SQM_UFo_${IFACE} \
	-m connbytes --connbytes ${CONNBUP} --connbytes-dir original --connbytes-mode bytes \
	-g QOS_SQM_UFO_${IFACE}
	$IP6TABLES -t mangle -A QOS_SQM_UFo_${IFACE} \
	-m connbytes --connbytes ${CONNBDN} --connbytes-dir reply --connbytes-mode bytes \
	-g QOS_SQM_UFO_${IFACE}

	# reply direction
	$IP6TABLES -t mangle -A QOS_SQM_UFr_${IFACE} \
	-m connbytes --connbytes ${CONNBDN} --connbytes-dir original --connbytes-mode bytes \
	-g QOS_SQM_UFR_${IFACE}
	$IP6TABLES -t mangle -A QOS_SQM_UFr_${IFACE} \
	-m connbytes --connbytes ${CONNBUP} --connbytes-dir reply --connbytes-mode bytes \
	-g QOS_SQM_UFR_${IFACE}
fi

# <<< --- End of the hook

# After having set up all the above rules, the final task is to get the firewall to actually run them
# Hook the above rules into the firewall path
ipt -t mangle -A POSTROUTING -o ${IFACE} -m connmark --mark 0/${DSCPFND} -j QOS_SQM_${IFACE}

}

ipt_destruct() {
	ipt -t mangle -D POSTROUTING -o ${IFACE} -m connmark --mark 0/${DSCPFND} -j QOS_SQM_${IFACE}
	ipt -t mangle -F QOS_SQM_US_${IFACE}
	ipt -t mangle -F QOS_SQM_US_REMAP_${IFACE}
	ipt -t mangle -F QOS_NFA_UN_${IFACE}
	ipt -t mangle -F QOS_SQM_UFo_${IFACE}
	ipt -t mangle -F QOS_SQM_UFr_${IFACE}
	ipt -t mangle -F QOS_SQM_UFO_${IFACE}
	ipt -t mangle -F QOS_SQM_UFR_${IFACE}
	ipt -t mangle -F QOS_SQM_${IFACE}

	ipt -t mangle -X QOS_SQM_US_${IFACE}
	ipt -t mangle -X QOS_SQM_US_REMAP_${IFACE}
	ipt -t mangle -X QOS_NFA_UN_${IFACE}
	ipt -t mangle -X QOS_SQM_UFo_${IFACE}
	ipt -t mangle -X QOS_SQM_UFr_${IFACE}
	ipt -t mangle -X QOS_SQM_UFO_${IFACE}
	ipt -t mangle -X QOS_SQM_UFR_${IFACE}
	ipt -t mangle -X QOS_SQM_${IFACE}
}

sqm_prepare_script() {
	do_modules
	verify_qdisc $QDISC "cake" || return 1
	ipt_setup
}
